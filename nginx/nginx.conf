# NGINX is configured to acts a web server serving the frontends static files
# and as a reverse proxy for the WS connection with the backend.
# For more detailed configuration of the WS reverse proxy please visit:
# https://www.nginx.com/blog/websocket-nginx/
# https://gist.github.com/gmanau/4f5bdb223d1e13417a3e

server {

    listen          ${SERVICE_PORT};
    root            /src/www/app;

    # Misc settings.
    charset     utf-8;
    client_max_body_size 1024m;

    # When defining a hostname on a proxy_pass directive, nginx resolves it
    # upon initialization, and then uses the IP address. When dealing with
    # upstreams in docker containers, their IP's may frequently change. To
    # work around this, we use a variable as a proxy_pass target, and define a
    # resolver. This causes nginx to periodically re-resolve the upstream
    # hostnames. The IP address 127.0.0.11 belongs to docker's builtin
    # DNS server. See https://tenzer.dk/nginx-with-dynamic-upstreams/ for more
    # details.
    resolver 127.0.0.11 ipv6=off valid=10s;


    # all locations from any origin are allowed
    add_header                  Access-Control-Allow-Origin *;
    add_header                  Access-Control-Allow-Methods "POST, GET, OPTIONS, DELETE, PATCH";


    # --------------------------------------------------------------------
    # Core SPA Routing:
    # This is crucial for single-page applications (SPAs) like React.
    # It tries to serve the requested file ($uri), then the requested directory ($uri/),
    # and if neither is found, it falls back to index.html.
    # This ensures client-side routing (e.g., React Router) works correctly.
    # --------------------------------------------------------------------
    location / {
        try_files $uri $uri/ /index.html;

        # Optional: Add common headers for caching and security
        # Adjust caching headers based on your needs.
        # For immutable assets (e.g., hashed filenames from Vite), you might use longer cache times.
        # For index.html, you typically want shorter or no-cache.
        # Basic security headers (recommended)
        add_header X-Frame-Options "DENY";
        add_header X-Content-Type-Options "nosniff";
        add_header X-XSS-Protection "1; mode=block";
        add_header Referrer-Policy "no-referrer-when-downgrade";

        # For index.html, you might want to prevent caching:
        if ($uri = '/index.html') {
            add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
            expires off;
        }
    }

     # --------------------------------------------------------------------
    # Service Worker (sw.js) Configuration:
    # - Must be served from the root scope (e.g., /sw.js) for security reasons.
    # - Must have 'Content-Type: application/javascript'.
    # - Crucially, it should NOT be cached by Nginx aggressively, so the browser
    #   always fetches the latest version to detect updates.
    # --------------------------------------------------------------------
    location = /sw.js {
        # Ensure the correct Content-Type
        add_header Content-Type application/javascript;
        # Prevent caching for the service worker script
        add_header Cache-Control "no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0";
        expires off;
        # Serve the file directly
        try_files $uri =404;
    }

    # --------------------------------------------------------------------
    # Web App Manifest Configuration:
    # - Needs 'Content-Type: application/manifest+json'.
    # - Can be cached, as its content typically changes only with new builds.
    # --------------------------------------------------------------------
    location = /manifest.webmanifest { # Vite PWA often uses .webmanifest
        add_header Content-Type application/manifest+json;
        expires 1h; # Cache for 1 hour, adjust as needed
        add_header Cache-Control "public, max-age=3600";
        try_files $uri =404;
    }

    # If your manifest is named manifest.json, use this instead:
    # location = /manifest.json {
    #     add_header Content-Type application/manifest+json;
    #     expires 1h;
    #     add_header Cache-Control "public, max-age=3600";
    #     try_files $uri =404;
    # }


    # define error page
    error_page 404 = @notfound;

    # error page location redirect 301
    location @notfound {
        return 301 /;
    }

    # Optional: Location block for static assets (e.g., CSS, JS, images)
    # This can be used for more aggressive caching of immutable assets.
    # Vite often hashes filenames, making them immutable.
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|eot|otf|ttf|woff|woff2)$ {
        expires 1y; # Cache static assets for 1 year
        add_header Cache-Control "public, immutable";
        try_files $uri =404; # Serve file directly, return 404 if not found
    }

    # Optional: Enable Gzip compression for faster loading
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_buffers 16 8k;
    gzip_http_version 1.1;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;
}
